[{"title":"PIL图像处理","date":"2018-02-26T07:27:51.000Z","path":"2018/02/26/PIL图像处理/","text":"一、安装环境1、centos7.+2、python 2.7+ 二、安装准备yum安装的的驱动准备：123yum install zlib zlib-devel yum install libjpeg libjpeg-level yum install freetype freetype-devel 下载PIL库12wget http://effbot.org/downloads/Imaging-1.1.7.tar.gz # 下载PILtar xvfz Imaging-1.1.7.tar.gz # 解压PIL更改setup文件的值#123456TCL_ROOT = \"/usr/lib64/\" JPEG_ROOT = \"/usr/lib64/\" ZLIB_ROOT = \"/usr/lib64/\" TIFF_ROOT = \"/usr/lib64/\" FREETYPE_ROOT = \"/usr/lib64/\" LCMS_ROOT = \"/usr/lib64/\"再执行：1python setup.py build_ext -i # 检测是否正常 正常输出：1234567891011121314151617PIL 1.1.7 SETUP SUMMARY -------------------------------------------------------------------- version 1.1.7 platform linux2 2.6.6 (r266:84292, Jan 22 2014, 09:42:36) [GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] -------------------------------------------------------------------- --- TKINTER support available --- JPEG support available --- ZLIB (PNG/ZIP) support available --- FREETYPE2 support available *** LITTLECMS support not available -------------------------------------------------------------------- To add a missing option, make sure you have the required library, and set the corresponding ROOT variable in the setup.py script. To check the build, run the selftest.py script. TKINTER和LITTLECMS 可能出现support not available情况，但是不影响PIL的使用。 三、安装1python setup.py install 四、使用引用：1from PIL import Image方法一、将第一张图放到第二张图上，JPG放到JPG/PNG上：123456789101112131415def merge_jpg(): base_img = Image.open(ur'1.jpg') region = Image.open(ur'2.jpg') region = img_two_path box = (89, 422, 661, 818) \"\"\" 图片截取框box值(依次是) 1：开始距离左边横向位置， 2：开始距离顶部竖直位置， 3：结束距离左边横向位置， 4：结束距离顶部竖直位置 \"\"\" region = region.resize((box[2] - box[0], box[3] - box[1])) base_img.paste(region, box) # 合成图片 return base_img方法二、将第三张图放到第二张图上，PNG放到JPG/PNG上：123456789101112131415161718def merge_png(imgs, box, path): \"\"\" :param imgs: 图片流内容 :param box: 截取位置 :param path: 本地图片位置 :return: 返回图片流 \"\"\" # imgs = Image.open('2.png') # box = (86, 680, 360, 822) # path = ur'2.png' target = Image.new('RGBA', imgs.size, (0, 0, 0, 0)) region = Image.open(path) region = region.convert(\"RGBA\") region = region.resize((box[2] - box[0], box[3] - box[1])) target.paste(region, box) r, g, b, a = target.split() imgs.paste(target, (0, 0), mask=a) return imgs","tags":[{"name":"PIL","slug":"PIL","permalink":"http://yoursite.com/tags/PIL/"},{"name":"图像处理","slug":"图像处理","permalink":"http://yoursite.com/tags/图像处理/"}]},{"title":"python装饰器","date":"2018-02-12T09:36:17.000Z","path":"2018/02/12/python装饰器/","text":"装饰器&emsp;&emsp; 无论是flask还是django，写路由验证签名的时候，用装饰器会比调用方法看起来要简洁些。经常要用到这个装饰器的知识，所以就写了这个文章； 注意点&emsp;&emsp;①在这里有几点需要注意，需要引入functools来保证调用装饰器后，原本该使用的方法还是原来的那个方法名，如果没加则会出现方法重名；&emsp;&emsp;②客户端所有的参数是以JSON方式传输到服务端，验证签名的字段固定为【sign】，当然你喜欢也可更改&emsp;&emsp;③客户端参与验证的key需要与服务端一致，并且字段名为【key】，当然你喜欢也可更改&emsp;&emsp;PS：如果你只有一个地方要使用，则可以忽略这个； 废话不多说，直接贴代码123456789101112131415161718192021222324252627282930313233343536373839# coding=utf-8\"\"\"Created on 2017年2月12日@author: nice丶柠檬\"\"\"from flask import request, jsonifyimport functools# 接口验证签名def api_auth(func): @functools.wraps(func) # 注意点① def decorator(*args, **kwargs): try: all_param = request.data # 注意点② all_param = eval(all_param) strs = '' all_key = all_param.keys() all_key.sort() for x in all_key: if x == 'sign': continue strs += x + \"=\" + all_param[x] + \"&amp;\" strs += \"key=*****\" # 注意点③ sign_server = hash_md5(strs) if sign_server == all_param['sign']: return func(*args, **kwargs) else: return jsonify(&#123;'status': 400&#125;) except Exception as e: print e return jsonify(&#123;'status': 500&#125;) return decorator # MD5加密方式def hash_md5(md5_str): m = hashlib.md5() m.update(md5_str) return m.hexdigest()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]},{"title":"数据库同步","date":"2018-01-08T01:33:12.000Z","path":"2018/01/08/数据库同步/","text":"1&gt;在工作中经常会出现迁移数据库，但是手动迁移又会有诸多数据不一致问题。&nbsp;&nbsp;废话不多说直接贴代码！&nbsp;&nbsp;PS：运行环境python 2.7 123456789101112131415161718192021222324252627282930313233# coding=utf-8import threadingimport ostable_list = '数据库表名，逗号分隔'print len(table_list.split(',')) # 打印有多少个表要同步def start(one, two): table_list_all = table_list.split(',')[one: two] for x in table_list_all: cmd = \"mysqldump -h host_ip -uusername -ppassword --databases db_name --tables %s |\" \\ \" mysql -h host_ip -uusername -ppassword db_name \" % x print cmd os.popen(cmd) print \"success\"threads = []t1 = threading.Thread(target=start, args=(0, 20))threads.append(t1)t3 = threading.Thread(target=start, args=(20, 40))threads.append(t3)t4 = threading.Thread(target=start, args=(40, 60))threads.append(t4)if __name__ == '__main__': for t in threads: t.setDaemon(True) import time time.sleep(1) t.start() for t in threads: t.join() print ' end ' 最后附上一句查询所有表名称的，原生SQL语句：&nbsp;&nbsp; SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_schema = ‘db_name’;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"pyhton数据库同步","slug":"pyhton数据库同步","permalink":"http://yoursite.com/tags/pyhton数据库同步/"},{"name":"脚本","slug":"脚本","permalink":"http://yoursite.com/tags/脚本/"}]},{"title":"下载文件","date":"2017-12-19T01:03:06.000Z","path":"2017/12/19/下载文件/","text":"1&gt; 工作中经常爬取资源，时常要用到下载。所以在网上找了找下载文件的部分代码。然后结合了之前的下载，写了一个简单的下载文件类。&nbsp;&nbsp;copy了一部分代码，源站地址忘了，还望源帖主包含123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161# coding=utf-8\"\"\"Created on 2017年12月18日@author: nice、柠檬---------------------------*****---------------------------类说明：文件下载会根据文件大小进行调用什么方法进行下载，下载完成后返回本地文件存储路径。配置属性 在download_file的__init__初始方法中设置---------------------------*****---------------------------文件下载方法，调用方式：方式①：download_file(url:URL链接地址).start()方式②：downloads = download_file(url:URL链接地址)downloads.start()示例1：download_file('http://cdn.seegif.com/i/171120/060301249789.jpg').start()示例2：downloads = download_file('http://cdn.seegif.com/i/171120/060301249789.jpg')downloads.start()\"\"\"import threadingimport requestsimport urllib2import timeimport os# 下载文件类class download_file(object): def __init__(self, url): \"\"\" @summary: 类方法操作，链接文件下载，根据文件大小进行调用方法操作。 ①、大文件使用线程拆分，同时下载然后在后台拼接存储 ②、小文件使用普通下载 :param url: 需要下载的图片地址 :param local_path: 本地文件存储根目录 :param thread_num: 文件下载时允许开启的最大线程数 :param maximum: 文件下载使用方法临界值设定，以M为单位 \"\"\" self.url = url self.local_path = \"/Users/steve/Desktop/video_download\" self.thread_num = 4 self.maximum = 5 @staticmethod def _file_mk_dirs(path): \"\"\" @summary: 创建本地文件路径 :param path: 路径地址 \"\"\" if os.path.exists(path): pass else: os.makedirs(path) def _mk_dir_(self): \"\"\" :return: 调用方法，将链接路径分割出域名后面的路由路径，再调用创建方法进行创建 \"\"\" domain = self.url.split(\"//\")[1].split('/')[0] path = self.url.split(domain)[1] self.file_name = self.url.split('/')[-1] self.local_path = self.local_path + path[0:path.rfind('/')] self._file_mk_dirs(self.local_path) return self.choice_download_methods() def choice_download_methods(self): \"\"\" :return: 请求链接拿到文件大小，然后在进行下载文件 \"\"\" opener = urllib2.build_opener() req = opener.open(self.url) meta = req.info() file_size = int(meta.getheaders(\"Content-Length\")[0]) if file_size / 1024.0 / 1024.0 &gt; self.maximum: return self.download_big_file(file_size) else: return self.download_small_file() def download_big_file(self, file_size): \"\"\" 下载大文件方法 :param file_size: 文件大小 :return: 本地文件路径地址，上传状态 \"\"\" try: # 获取文件的大小和文件名 threading.BoundedSemaphore(self.thread_num) # 允许线程个数 step = file_size // self.thread_num end = -1 temp_file = open(self.local_path+'/'+self.file_name, 'w') temp_file.close() mtd_list = [] with open(self.local_path+'/'+self.file_name, 'rb+')as f: # 获得文件句柄 file_no = f.fileno() # 返回一个整型的文件描述符，可用于底层操作系统的 I/O 操作 while end &lt; file_size - 1: start = end + 1 end = start + step - 1 if end &gt; file_size: end = file_size print ('Start:%s,end:%s' % (start, end)) dup = os.dup(file_no) # 复制文件句柄 fd = os.fdopen(dup, 'rb+', -1) t = My_big_thread(self.url, start, end, fd) t.start() mtd_list.append(t) for i in mtd_list: i.join() f.close() status = 'success' except Exception as e: print e status = 'error' data = &#123; 'status': status, 'url': self.local_path+'/'+self.file_name &#125; return data def download_small_file(self): \"\"\" 下载小文件方法 :return: 本地文件路径地址，上传状态 \"\"\" import urllib try: urllib.urlretrieve(self.url, self.local_path+'/'+self.file_name) status = 'success' except urllib.ContentTooShortError: print 'Network conditions is not good.Reloading.' time.sleep(1) status = 'error' data = &#123; 'status': status, 'url': self.local_path+'/'+self.file_name &#125; return data def start(self): return self._mk_dir_()# 下载大文件调用方法类class My_big_thread(threading.Thread): def __init__(self, url, start_pos, end_pos, f): super(My_big_thread, self).__init__() self.url = url self.start_pos = start_pos self.end_pos = end_pos self.fd = f def download(self): headers = &#123;'Range': 'bytes=%s-%s' % (self.start_pos, self.end_pos)&#125; res = requests.get(self.url, headers=headers) self.fd.seek(self.start_pos) self.fd.write(res.content) self.fd.close() def run(self): self.download()","tags":[{"name":"download","slug":"download","permalink":"http://yoursite.com/tags/download/"},{"name":"下载","slug":"下载","permalink":"http://yoursite.com/tags/下载/"},{"name":"多线程下载","slug":"多线程下载","permalink":"http://yoursite.com/tags/多线程下载/"}]},{"title":"firewall-防火墙命令相关","date":"2017-12-06T10:23:17.000Z","path":"2017/12/06/firewall-防火墙命令相关/","text":"&emsp;&emsp;本文是一些简单的防火墙操作,工作中记录使用到的 1&gt;防火墙阻止某个IP进行访问1firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=\"125.122.210.18\" drop' 2&gt;防火墙只允许某个IP进行访问1firewall-cmd --permanent --add-rich-rule 'rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept' 3&gt;防火墙开放80端口1firewall-cmd --zone=public --add-port=80/tcp --permanent 4&gt;添加某个端口段1firewall-cmd --zone=public --add-port=4400-4600/udp --permanent 5&gt;所有更改都需要进行防火墙重加载，命令如下1firewall-cmd --reload","tags":[{"name":"firewall","slug":"firewall","permalink":"http://yoursite.com/tags/firewall/"},{"name":"防火墙","slug":"防火墙","permalink":"http://yoursite.com/tags/防火墙/"}]},{"title":"python上月,本月,上周通用方法","date":"2017-12-04T12:50:41.000Z","path":"2017/12/04/python上月-本月-上周通用方法/","text":"前言&emsp;&emsp;此类函数是一个简单的日期函数，本人自行创作，如果Copy请大佬们注明出处。喜欢的可以进行收藏！&emsp;&emsp;之前有写一个js的日期函数，刚好在写后台的时候又用到了上周，上月，本月，所有就又写了个函数，后期可能还会加上近七天，30天的日期方法 废话不多说，直接贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- coding: UTF-8 -*-\"\"\"Created on 2017年12月04日@author: 橘色橙子 \"\"\"import calendarimport timeimport datetimeclass get_day_list(object): def __init__(self, day_type=None, data_type=None): \"\"\" :param day_type: 需要返回的数据类型， 上月：last_month 上周：week 本月：month 今天： 可不传 :param data_type: 需要返回的日期数据，是全部的列表还是，只需要最大和最小； 列出所有日期：list_all 只需要最大和最小： 可不传，或者传 min \"\"\" self.day_type = day_type self.data_type = data_type self.return_data = list() self.day_now = time.localtime() self.time_format_one = '%d-%02d-%02d' self.time_format_two = '%Y-%m-%d' def list_day(self): \"\"\" 根据不同的日期选择进行，返回数据 :return: \"\"\" if self.day_type == 'last_month': if self.day_now.tm_mon == 1: day_year = self.day_now.tm_year - 1 day_month = 12 else: day_year = self.day_now.tm_year day_month = self.day_now.tm_mon - 1 # 如果是1月则年份减一，月份变成12月 self.type_month(day_year, day_month) elif self.day_type == \"week\": self.type_week() elif self.day_type == 'month': day_now = time.localtime() day_year = day_now.tm_year day_month = day_now.tm_mon self.type_month(day_year, day_month) else: self.return_data.append(time.strftime(self.time_format_two)) self.return_data.append(time.strftime(self.time_format_two)) return self.return_data def get_Week_DAY(self, x): \"\"\" :param x: 传入获取星期几， 1是周一，7是周日 \"\"\" one_day = (datetime.datetime.today() - datetime.timedelta(days=time.localtime().tm_wday + x)).strftime( self.time_format_two) return one_day def get_one_day(self, day_year, day_month, x): \"\"\" :param day_year: 日期的年份 :param day_month: 日期的月份 :param x: 日期的天数 \"\"\" one_day = self.time_format_one % (day_year, day_month, x) return one_day def type_month(self, day_year, day_month): \"\"\" :param day_year: 传入年份 :param day_month: 传入月份 :return: 返回值类型是list_all则返回所有列表，否则返回最大和最小 \"\"\" weekday, monthRange = calendar.monthrange(day_year, day_month) if self.data_type == 'list_all': for x in range(1, monthRange + 1): self.return_data.append(self.get_one_day(day_year, day_month, x)) else: self.return_data.append(self.get_one_day(day_year, day_month, 1)) self.return_data.append(self.get_one_day(day_year, day_month, monthRange)) def type_week(self): \"\"\" :return: 返回值类型是list_all则返回所有列表，否则返回最大和最小 \"\"\" if self.data_type == 'list_all': for x in range(1, 8)[::-1]: self.return_data.append(self.get_Week_DAY(x)) else: self.return_data.append(self.get_Week_DAY(7)) self.return_data.append(self.get_Week_DAY(1))","tags":[{"name":"上月","slug":"上月","permalink":"http://yoursite.com/tags/上月/"},{"name":"上周","slug":"上周","permalink":"http://yoursite.com/tags/上周/"},{"name":"本月","slug":"本月","permalink":"http://yoursite.com/tags/本月/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"日期","slug":"日期","permalink":"http://yoursite.com/tags/日期/"}]},{"title":"极光推送","date":"2017-11-29T08:32:57.000Z","path":"2017/11/29/极光推送/","text":"1&gt; 在写APP的时候，经常使用推送，因此此次采用极光的推送，写了一个公用类。&nbsp;&nbsp;此推送方法是一个简单的类，本人自行创作，如果Copy请大佬们注明出处，谢谢！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding: utf-8 -*-\"\"\"Created on 2017年11月29日@author: nice丶柠檬\"\"\"from app import Configimport jpushclass push_client(object): def __init__(self): \"\"\" 初始化链接类，创建一个推送连接 \"\"\" self._jpush = jpush.JPush(Config.app_key, Config.master_secret) \"\"\" Config.app_key: app 极光账号，本人从app配置文件导入 Config.master_secret: 极光密码，本人从app配置文件导入 \"\"\" self.push = self._jpush.create_push() self._jpush.set_logging('DEBUG') def all_push(self, msg, msg_data=None): \"\"\" 推送消息，所有 :param msg: 消息内容，标题 :param msg_data: 消息数据 :return: \"\"\" self.push.audience = jpush.all_ android = jpush.android(alert=msg, priority=1, style=1, alert_type=1, extras=msg_data) self.push.notification = jpush.notification(alert=msg, android=android) self.push.platform = jpush.all_ try: response = self.push.send() if response.__dict__['status_code'] == 200: return True else: return False except Exception as e: print e return False def user_client(self, msg, msg_data=None, uid=None): \"\"\" :param msg: 消息标题 :param msg_data: 消息透传客户端值 :param uid: 用户唯一ID :return: \"\"\" if uid is None: return False self.push.audience = jpush.alias(uid) android = jpush.android(alert=msg, priority=1, style=1, alert_type=1, extras=msg_data) self.push.notification = jpush.notification(alert=msg, android=android) self.push.platform = jpush.all_ try: response = self.push.send() if response.__dict__['status_code'] == 200: return True else: return False except Exception as e: print e return False 最后，感谢极光，提供的免费推送服务！！！","tags":[{"name":"推送","slug":"推送","permalink":"http://yoursite.com/tags/推送/"},{"name":"极光","slug":"极光","permalink":"http://yoursite.com/tags/极光/"}]},{"title":"python权重","date":"2017-11-13T09:03:26.000Z","path":"2017/11/13/python权重/","text":"序言&emsp;&emsp;工作的时候遇到了一个关于权重的问题，网上查了之后，有一些解决方法，从别人那学习学习，然后再自己重构。对于实际工作，更多的是序言在sql语句查询之后对结果的权重进行处理。所以就写了简单的一个类，方便使用。 1&gt;代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-\"\"\"Created on 2017年11月13日@author: nice丶柠檬\"\"\"import randomimport bisectclass weight_adv(object): def __init__(self): \"\"\" 初始化权重参数 \"\"\" self.two = [] self.one = [] self.num = 0 self.weight_sum = [] def weight_choice(self, weight): \"\"\" :return: :param weight: list对应的权重序列 :return:选取的值在原列表里的索引 \"\"\" for a in weight: self.num += a self.weight_sum.append(self.num) t = random.randint(0, self.num - 1) return bisect.bisect_right(self.weight_sum, t) def list_choice(self, dict_all): \"\"\" 传入LIST，取出所需要的数值 :param dict_all: 参数，权重数组，列表， 示例 ：[&#123;'a': 1&#125;, &#123;'b': 2&#125;, &#123;'c': 4&#125;, &#123;'d': 3&#125;] :return: 返回选中值 \"\"\" for for_one in dict_all: for for_two in for_one: self.one.append(for_two) self.two.append(for_one[for_two]) return self.one[self.weight_choice(self.two)] def dict_choice(self, dict_all): \"\"\" 传入字典值，取出所需要的数值 :param dict_all: 参数，权重字典 示例 ：&#123;'a': 1, 'b': 2, 'c': 4, 'd': 3&#125; :return: 返回选中值 \"\"\" for list_one in dict_all: self.one.append(list_one) self.two.append(dict_all[list_one]) return self.one[self.weight_choice(self.two)] 2&gt; 调用方法如下1234s = [&#123;'a': 1&#125;, &#123;'b': 2&#125;, &#123;'c': 4&#125;, &#123;'d': 3&#125;] print weight_adv().list_choice(s) # 数组参数调用a = &#123;'a': 1, 'b': 2, 'c': 4, 'd': 3&#125;print weight_adv().dict_choice(a) # 字典参数调用","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"权重","slug":"权重","permalink":"http://yoursite.com/tags/权重/"}]},{"title":"转码问题","date":"2017-10-11T05:41:58.000Z","path":"2017/10/11/转码问题/","text":"一、当json.loads()无法进行格式化数据，但使用evel()可以转格式，但中文乱码问题之笨办法解决方法。 ①、当显示为\\u6c42\\u8d22\\u7eff\\u6bdb，则使用这一方法进行转换。示例：使用： 12data = data.decode('unicode_escape')print data # 此时为正常的中文显示。 ②、当显示为u95fbu9e21u8d77u821e u5febu4e50u5411u94b1时则进行替换转码示例:使用：123import redata, num = re.subn('u', '\\\\u',data, flags=re.I) # 先替换成，unicode码,num可以忽略print data # 此时转成unicode 码了。但是还是无法使用，则继续需要第一种方法进行转码即可综合①、②方法结合的结果截图：","tags":[{"name":"转码","slug":"转码","permalink":"http://yoursite.com/tags/转码/"}]},{"title":"rm_命令","date":"2017-10-09T02:40:29.000Z","path":"2017/10/09/rm-命令/","text":"1&gt; rm 删除文件,包括特殊字符开头的文件①、一般文件删除，则使用如下命令即可1rm -f +文件名 # 非交互式删除文件，文件名支持通配符 ②、当文件为特殊字符开始的时候，这样进行删除则不成功，删除会出现失败，则使用如下命令删除，特殊字符开始的。1rm -f -- +文件名 # 非交互式删除文件，文件名支持通配符，‘*’ 注意：命令rm -f后面的 ‘--‘ 一定不能省略，否则将无法删除","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"rm","slug":"rm","permalink":"http://yoursite.com/tags/rm/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"Django笔记","date":"2017-09-14T07:59:37.000Z","path":"2017/09/14/Django笔记/","text":"前言&emsp;&emsp;此Django语法是编写时费力找到的，本人自行创作，如果Copy请大佬们注明出处。&emsp;&emsp;http://juziweb.oschina.io/2017/09/14/Django笔记 1&gt; Django后台管理界面将某个字段，改成radio方式进行单项选择—-简单粗暴直接贴出代码—- ①、models.py文件中写入12345678class userInfo(models.Model): ...... sex = models.IntegerField(default=1) # 性别 def __str__(self): return self.sex # 表名设置 class Meta: db_table = 'user' ②、admin.py文件中写入123456789101112131415from django.contrib import adminfrom django import formsfrom models import userInfofrom ph_com import downloadclass test(forms.ModelForm): sex = forms.ChoiceField(label='性别', widget=forms.RadioSelect(), choices=((u'1', u'男'), (u'0', u'女'),)) class Meta: forms.model = userInfoclass users(admin.ModelAdmin): list_display = ['uid', 'nickname'] form = testadmin.site.register(userInfo, users) ③、执行结果截图","tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"测试随笔","date":"2017-09-13T06:03:29.000Z","path":"2017/09/13/测试随笔/","text":"孤独&nbsp;&nbsp;曾经以为过好自己，即使我一个人那也挺好。我自己想去哪就去哪，旅游，出差，回家。什么时候想走就走。没有任何顾虑。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"js-本月、上个月、上周时间方法函数","date":"2017-09-13T02:07:10.000Z","path":"2017/09/13/js-本月、上个月、上周时间方法函数/","text":"前言&emsp;&emsp;此方法是一个简单的日期函数，本人自行创作，如果Copy请大佬们注明出处。&emsp;&emsp;http://juziweb.oschina.io/2017/09/13/js-本月、上个月、上周时间方法函数 1&gt; 本月日期获取函数—-获取月初一号至当前的日期—-123456789101112131415161718192021222324252627function month() &#123; var now = new Date(); //当前日期 var nowDay = now.getDate(); //当前日 var nowMonth = now.getMonth(); //当前月 var nowYear = now.getFullYear(); //当前年 var str_Month = ''; if (nowMonth + 1 &lt; 9 &amp;&amp; nowMonth !== 0) &#123; str_Month = '0' + (nowMonth + 1).toString(); &#125; else if (nowMonth === 0) &#123; str_Month = '0' + (nowMonth + 1).toString(); nowYear = nowYear - 1 &#125; else &#123; str_Month = (nowMonth + 1).toString(); &#125; var str_day = ''; if (nowDay &lt; 9) &#123; str_day = '0' + nowDay.toString(); &#125; else &#123; str_day = nowDay.toString(); &#125; var month_start = nowYear + '-' + str_Month + '-01'; var month_end = nowYear + '-' + str_Month + '-' + str_day; window.location.href = '（路由地址）' + month_start + '_' + month_end // 路由跳转函数，GET请求地址&#125; 2&gt; 上个月日期获取函数—-获取上个月初一号至月末的日期—-1234567891011121314151617181920212223242526272829function last_moth() &#123; var now = new Date(); //当前日期 var nowMonth = now.getMonth(); //当前月 var nowYear = now.getFullYear(); //当前年 var str_Month = ''; if ((nowMonth + 1) &lt; 9 &amp;&amp; nowMonth !== 0) &#123; str_Month = '0' + (nowMonth).toString(); &#125; else if (nowMonth === 0) &#123; str_Month = '0' + (nowMonth + 1).toString(); nowYear = nowYear - 1 &#125; else &#123; str_Month = (nowMonth).toString(); &#125; var years = 0; var months = 0 if (now.getMonth() === 0) &#123; years = now.getFullYear(); months = now.getMonth() &#125; else &#123; years = now.getFullYear() - 1; months = 12 &#125; var ss = new Date(years, months, 0); var month_start = nowYear + '-' + str_Month + '-01'; var month_end = nowYear + '-' + str_Month + '-' + ss.getDate() window.location.href = '（路由地址）' + month_start + '_' + month_end // 路由跳转函数，GET请求地址&#125; 3&gt; 上周日期获取函数—-获取上周一至上周日的日期—-12345678910111213141516171819202122232425function week() &#123; var now = new Date(); var nowTime = Date.parse(now); var weekDay = now.getDay(); var oneDay = 24 * 60 * 60 * 1000; var last_day = nowTime - weekDay * oneDay; var first_day = nowTime - (weekDay + 6) * oneDay; var sunday = new Date(last_day); var monday = new Date(first_day); window.location.href = '（路由地址）' + int_str_day(monday) + '_' + int_str_day(sunday)&#125;function int_str_day(time_stamp) &#123; var int__Day = time_stamp.getDate(); //日 var int_str_Month = time_stamp.getMonth(); //月 var int_str_Year = time_stamp.getFullYear(); //年\\\\ if (int__Day &lt; 9) &#123; int__Day = '0' + int__Day.toString(); &#125; int_str_Month = int_str_Month + 1; if (int_str_Month &lt; 9) &#123; int_str_Month = '0' + int_str_Month.toString() &#125; var str_int_day = int_str_Year + '-' + int_str_Month + '-' + int__Day; return str_int_day&#125; 3&gt; 最近指定日期获取函数—-传入dates值为int型，调用函数则返回时间字符串，开始时间在前面，结束时间在后面。传递值为1则返回相同值，即返回昨天时间字符串—-1234567891011121314151617181920212223242526function return_days(dates) &#123; var now = new Date(); var nowTime = Date.parse(now); var oneDay = 24 * 60 * 60 * 1000; var last_day = new Date(nowTime - dates * oneDay); var first_day = new Date(nowTime); if (dates == 1) &#123; return (int_str_day(last_day) + '_' + int_str_day(last_day)) &#125; return (int_str_day(last_day) + '_' + int_str_day(first_day))&#125;function int_str_day(time_stamp) &#123; var int__Day = time_stamp.getDate(); //日 var int_str_Month = time_stamp.getMonth(); //月 var int_str_Year = time_stamp.getFullYear(); //年\\\\ if (int__Day &lt;= 9) &#123; int__Day = '0' + int__Day.toString(); &#125; int_str_Month = int_str_Month + 1; if (int_str_Month &lt;= 9) &#123; int_str_Month = '0' + int_str_Month.toString() &#125; var str_int_day; str_int_day = int_str_Year + '-' + int_str_Month + '-' + int__Day; return str_int_day&#125;","tags":[{"name":"JS日期获取","slug":"JS日期获取","permalink":"http://yoursite.com/tags/JS日期获取/"},{"name":"上月","slug":"上月","permalink":"http://yoursite.com/tags/上月/"},{"name":"上周","slug":"上周","permalink":"http://yoursite.com/tags/上周/"},{"name":"本月","slug":"本月","permalink":"http://yoursite.com/tags/本月/"}]},{"title":"page-简单的分页写法","date":"2017-09-13T01:45:23.000Z","path":"2017/09/13/page-简单的分页写法/","text":"前言&emsp;&emsp;此分页是一个简单的分页操作，本人自行创作，如果Copy请大佬们注明出处。&emsp;&emsp;http://juziweb.oschina.io/2017/09/13/page-简单的分页写法 1&gt; 页面代码12345678&lt;!--=================分页=================--&gt; &lt;div class=\"page\" id=\"page_info\"&gt; &lt;div class=\"page_1\"&gt;&amp;nbsp;当前页数：&lt;span id=\"currentPage\"&gt;&lt;/span&gt;&lt;i&gt;/&lt;/i&gt;&amp;nbsp;&lt;span id=\"totalPage\"&gt;&lt;/span&gt; 页&lt;/div&gt; &lt;a id=\"page_start\"&gt;首页&lt;/a&gt; &lt;a class=\"span_1\" id=\"toPre\"&gt;上一页&lt;/a&gt; &lt;a class=\"span_1\" id=\"toNext\"&gt;下一页&lt;/a&gt; &lt;a id=\"page_end\"&gt;&lt;span id=\"all_page\" style=\"display:none\"&gt;&lt;/span&gt;尾页&lt;/a&gt;&lt;/div&gt; 2&gt; CSS样式代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*=========================分页样式=======================*/.page&#123; margin: 50px 0;&#125;.page_1&#123; display: inline-block; font-size: 16px; color: #00ABEC; line-height: 40px; padding: 0 15px; margin: 0 5px; border-radius: 3px;&#125;.page a&#123; display: inline-block; font-size: 14px; color: #00ABEC; border: 1px #00ABEC solid; line-height: 40px; padding: 0 15px; margin: 0 5px; border-radius: 3px; cursor: pointer;&#125;.page_1&#123; display: inline-block; font-size: 14px; color: #00ABEC; border: 1px #00ABEC solid; line-height: 40px; padding: 0 15px; margin: 0 5px; border-radius: 3px; cursor: pointer; margin-top: 1%;&#125;.span_1&#123; display: inline-block; font-size: 14px; color: #00ABEC; border: 1px #00ABEC solid; line-height: 40px; padding: 0 15px; margin: 0 5px; border-radius: 3px; cursor: pointer;&#125;.page a:hover&#123; color: white; background-color:#00ABEC ;&#125;.span_1:hover&#123; color: white; background-color:#00ABEC ;&#125; 3&gt; JS代码12345678910111213141516171819202122232425262728//上一页 $('#toPre').click(function () &#123; var currentPage = parseInt($('#currentPage').html()); if (currentPage &gt; 1 ) var page = currentPage - 1; else page =currentPage; query(page) &#125;);//下一页 $('#toNext').click(function () &#123; var currentPage = parseInt($('#currentPage').html()); var all_page = $('#all_page').html(); if (currentPage &lt; all_page ) var page = currentPage + 1; else page =currentPage; query(page) &#125;);//首页 $('#page_start').click(function () &#123; query(1) &#125;);//尾页 $('#page_end').click(function () &#123; var all_page = $('#all_page').html(); query(all_page) &#125;);","tags":[{"name":"page","slug":"page","permalink":"http://yoursite.com/tags/page/"},{"name":"分页","slug":"分页","permalink":"http://yoursite.com/tags/分页/"}]},{"title":"mysql-语法","date":"2017-09-13T01:27:48.000Z","path":"2017/09/13/mysql-语法/","text":"1&gt; 时间与时间戳对比查询，结果时间戳转时间 ①、查询条件为时间字符串的数据对比—-查询当天数据—-1to_days(时间字段名) = to_days(now()) —-查询最近七天数据—-1DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(时间字段名) —-查询最近一月数据—-1DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(时间字段名)","tags":[{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"python语法","date":"2017-09-05T06:43:50.000Z","path":"2017/09/05/python语法/","text":"1&gt; 数组中的字典排序，根据数组中字典中某个值进行排序；语法：排序后字典赋值 = sorted(字典名称, key=lambda 字典名称: 字典名称[‘字段值’])举例：根据all_data中的day进行排序1all_data = sorted(all_data, key=lambda all_data: all_data['day'])","tags":[{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hexo，部署我的博客……","date":"2017-08-24T07:33:07.000Z","path":"2017/08/24/Hexo，部署我的博客……/","text":"前言&emsp;&emsp;本人使用Mac电脑，因此所有操作命令是Mac命令。非Mac环境可以绕道走了,当然有兴趣的可以继续看一看…… 第一步: 安装码云&emsp;&emsp;使用MAC自带的brew进行安装：命令如下： 1brew install git #Mac电脑使用brew安装git 第二步：安装node.js&emsp;&emsp;依旧使用MAC自带的brew进行安装：命令如下： 12brew install node #最新版的node.js的包中已经集成了npm包管理工具使用 node -v 检验,也可使用npm -v 进行检验。 第三步：安装Hexo，部署1.安装&emsp;&emsp;使用上一步安装的npm命令进行安装，进行此步骤的时候确保前面两个步骤都已经进行完成。 1npm install hexo -g #-g表示全局安装, npm默认为当前项目安装 2.部署&emsp;&emsp;①、创建一个文件夹，到哪里都是可以的： 1例如： mkdir /Users/####(我的主目录)/blog # 创建文件夹 &emsp;&emsp;②、然后进入这个目录并执行以下命令：1cd /Users/####(我的主目录)/blog # 移动到该文件夹&emsp;&emsp;③、执行hexo命令，生成自己的静态文件：123hexo init #执行init命令初始化hexo到你指定的目录hexo generate #自动根据当前目录下文件,生成静态网页hexo server #运行本地服务通过浏览器访问：http://localhost:4000即可进行验证是否正常启动。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]}]